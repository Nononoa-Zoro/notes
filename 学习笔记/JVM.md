### JAVA内存区域

- 线程公有

  **方法区**：用于存储**类信息**，**常量**，**静态变量，即时编译后的数据**，也被称为**永久代**。很少发生GC，在这里的GC主要是对常量池和类型卸载的回收。

  **堆**：**存放对象实例**的地方，分为**新生代**（Eden,From Survivor,To Survivor）和**年老代**。是垃圾回收的主要区域。

  

- 线程私有

  **虚拟机栈**：为Java方法服务，每个方法在执行时都会创建一个栈帧，用于存储**局部变量表**，**操作数栈**，**动态链接**，**方法出口**等信息。

  本地方法栈：为native方法服务，本地方法执行的是Native服务

  程序计数器：指向下一条将要执行的字节码。

  

- 直接内存

  直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存被频繁地使用，属于堆外内存。

  Java NIO使用native函数直接分配堆外内存，然后在堆中使用Direct ByteBuffer对象作为这块内存的引用进行操作。

###虚拟机参数

- -Xms20m JVM初始分配的内存
- -Xmx20m JVM最大可用内存
- -Xss20m 单个线程栈空间的大小 
- -XX:MaxDirectMemorySize 本机直接内存
- -Xmn:10m 新生代10M
- -XX：SurvivorRatio=8 新生代中Eden和Survivor空间比例是8：1
- -XX：PretenureSizeThreshold 大于这个值的对象直接进入老年代
- -XX:   MaxTenuringThreshold   大于这个值的被认为是岁数很大的对象，会放入老年代

###垃圾回收

- 如何判断对象已死？

  1. 引用计数法（有引用就+1，没有引用就-1），缺点：不能解决循环引用问题。A->B,B->A

     所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 

  2. 可达性分析算法

     “GC Roots"作为根起点，从这些节点开始向下搜索，当一个对象到GC Roots没有任何引用链的话，说明这个对象是不可用的，应该回收。

- GC Roots对象有哪些？

  1. 虚拟机栈中的引用对象。（栈帧中的本地变量表）
  2. 方法区中类的静态属性引用的对象
  3. 方法区中常量引用的对象
  4. 本地方法栈中的JNI（本地方法调用）引用的对象

- 当GC ROOTS对象不能到达某些对象时，这些对象被视为垃圾，但是不会立即回收。会进行一次筛选，筛选的条件是是否有必要进行finalize()方法，如果有，那么对象会被放入F-Queue中，这是一个低优先级的线程。法。
###四种引用
- 强引用：就是程序中普遍存在的。`Object obj=new Object() `，只要强引用存在，GC永远不会回收掉被引用的对象
- 软引用：描述有用但不是必须的对象。当内存空间足够时，则能保留在内存之中，如果内存空间在垃圾回收之后非常紧张则可以回收这些对象。（内存不足时回收）
- 弱引用：只能生存到下一次垃圾回收之前，无论内存是否充足都会回收弱引用。
- 虚引用：该对象被垃圾回收器回收时会得到一个系统通知。虚引用主要用来跟踪对象被垃圾回收的活动。 
###垃圾回收算法
- **标记-清除算法**：首先标记出所有要回收的对象，在标记完成之后统一回收所有被标记的对象。缺点：产生大量不连续的内存碎片，导致以后无法分配较大对象。
- **复制算法**：将可用内存分为大小相等的两块。每次使用其中的一块，当这块内存使用完了，就将存活的对象复制到另一块中，然后把已经使用过的内存空间一次性清理掉。缺点：将可用内存减少一半，代价太高。在堆中的**新生代**采用复制算法回收，并且不需要按照1:1划分内存空间，因为新生代98%的对象是”朝生夕死“，所以Eden和Survivor的比例是8:1。
- **标记-整理算法**：**老年代**使用的算法，让所有存活对象向一端移动，然后清理掉边界以外的内存。
- **分代收集算法**：Java堆分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。由于**新生代**每次GC都有大批对象死去，所以**采用复制算法**。而**老年代**中的对象存活率高，**采用”标记-整理“算法**。
###对象的分配
- 对象优先在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
- 大对象直接存放在老年代（byte[ ]数组）
- 长期存活的对象进入老年代。（在Minor GC中存活的对象的年龄默认增加一岁，达到15岁就会被放到老年代中）
###Minor GC 和 Full GC
- 新生代GC（Minor GC）：是指在新生代发生的垃圾回收。（Eden区满了触发）
- 年老代GC（Full GC）：是指在老年代发生的GC。（old区内存不足触发）
###虚拟机类加载机制
- 在Java中类的加载，链接，初始化都是在**程序运行期间**完成的。这恰恰保证了Java语言的动态扩展，程序可以等到运行时才确定实际的实现类。
- 类加载的生命周期
	1. **加载**
		1.1  通过**类全限定名**获得此类的二进制流
		1.2  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
		1.3  在内存中生成一个代表这个类的java.lang.class对象，作为方法去这个类的各种数据的访问入口
	2. **链接**
		2.1  验证：判断一个class文件是否复合规范
		2.2  准备：为**类变量**分配内存
		2.3  解析：将常量池内的符号引用替换为直接引用
	3. **初始化**：为类变量设置初始值
###类加载器
- 启动类加载器（BootStrap ClassLoader）：负责加载<JAVA_HOME>\lib目录中的类
- 扩展类加载器（Extension ClassLoader）：<JAVA_HOME>\lib\ext下面的所有类
- 应用程序类加载器（Application ClassLoader）：负责加载用户类路径下的指定类
###双亲委派模型
- 如果一个类加载器接收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都会传送到顶层的启动类加载器。只有当父类自己无法加载这个请求的时候，子加载器才会尝试自己加载。

- 双亲委派模型的优点：Java类随着它的类加载器一起具备了一种带优先级的层次关系。如，java.lang.object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器加载，因此Object类在程序的各类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行加载，那么系统就会出现很多自定义的Object。

  

### 为什么要分为Eden和Survivor? 

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。 



### 哪些对象会进入老年代

1. **大对象**直接进入老年代
2. **长期存活的对象**将进入老年代：如果对象在Eden中，并且在经过一次Minor GC之后仍然存活，那么该对象会转到Survivor中，且该对象的年龄+1，如果对象的年龄到达15岁就会转移到老年代。
3. **Suvivor区域空间不足**：假如在进行Minor GC的时候发现，存活的对象在ToSpace中放不下，那么就把存活的对象放入老年代。



### 什么时候会导致Full GC，MinorGC?

新生代内存不足导致MinorGC ，JVM内存不足导致Full GC。

如果某些对象由于以上原因需要被移动到老年代中，而老年代中没有足够空间容纳这个(些)对象，那么会触发一次Full GC，Full GC会对整个堆进行一次GC，如果Full GC后还有无法给新创建的对象分配内存，或者无法移动那些需要进入老年代中的对象，那么JVM抛出**OutOfMemoryError** 



### 简述JAVA的内存分配策略

1. 对象优先在Eden分配。
2. 大对象直接进入老年代。
3. 长期存活的对象进入老年代。（默认15岁）













