### 死锁

如何发生？

多个线程之间，每个线程都在请求其他线程占有的资源，同时不肯释放自己的资源，导致程序长时间等待。

如何解决？

1. ReentrantLock(可重入锁)：可重入锁可以响应中断，lock.LockInterruptibly()。表示线程可以通过响应中断来释放对资源的请求。
2. 限时等待-ReentrantLock: 可重入锁的trylock()方法会尝试请求资源，当一定时间请求不到资源时，释放对这个资源的请求。
3. ThreadLocal：为每一个线程分配一个资源。但是这个资源其实不是同一个对象。
4. CAS(Compare And Swap): 这是一种无锁机制，也就是乐观锁。如果你要修改的值=你预期的值，则将这个值进行修改。在mysql中使用的是版本号机制，如果当前版本号正好是上一个版本，说明没有其他人修改过这个数据，如果这个待修改的数据的版本号>=我的版本号，说明别人已经修改过数据，所以不可以修改。

# 产生死锁的四个必要条件

## 互斥条件

进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 

## 不可剥夺条件

进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。 

## 请求与保持条件

进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 

## 循环等待条件

存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。

![](D:\mdimage\20180320180138880.jpg)

## 预防死锁

1.破坏“互斥”条件: 

就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。

2.破坏请求等待条件

破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。 

方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 **“ 一次性分配**”方案。 

方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。 

3.破坏“不可抢占”条件： 

破坏“不可抢占”条件就是允许对资源实行抢夺。
方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。

4.破坏“循环等待”条件： 

破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。 
