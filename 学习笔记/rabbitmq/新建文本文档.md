### RabbitMQ的实用优点

应用解耦 

举例说明：有这样一个业务场景：我们在网上购买一件商品，支付成功之后库存要减少一，如果是传统的软件架构中，必须是先支付，然后再减少库存，这两个操作必须是在同一事务中，即操作原子性，但是这样做的话效率是极其低下的，如果使用RabbitMQ的话，我们需要将消息发送给各自的队列来进行消息处理，支付和库存的操作之间没有了关联性，这样支付系统和库存系统之间就进行了解耦。



流量削峰

rabbitMQ可以使用缓冲队列的方式，在访问量急剧增大的时候，减少并发访问的压力，比较常见的业务场景就是秒杀和签到系统 

 

异步处理 

很多的业务场景中，需要发出一个指示，但是并不要求立即执行，可能对什么时候执行，或者只要执行就可以了有不同的需求，而对于这样的场景，RabbitMQ提供不同的解决方法，用户发送发送的消息储存在RabbitMQ中，由rabbitMQ传递给消费者来进行消费，也可以通过死信队列来实现延迟队列的效果，让消息定时被消费等等。



### 消息基于什么传输，这样做有什么优点？

RabbitMQ是基于信道**Channel**的方式来传输数据，排除了使用TCP链接来进行数据的传输，因为TCP链接创建和销毁对于系统性能的开销比较大，且并发能力受系统资源的限制，这样很容易造成rabbitMQ的性能瓶颈。



### 如何确保消息正确的发送到RabbitMQ

发送方发送消息到RabbitMQ，有可能发送失败，失败的原因有如下的可能:

- 交换器无法根据自身的类型和路由键匹配到队列（mandatory）

- 当与路由键匹配的所有队列都没有消费者时（延时队列和死信队列）

  

**RabbitMQ提供发送方确认机制来去报消息正确发送到RabbitMQ服务** 

​	发送方确认机制是指消息生产者将信道设置成**confirm**模式，一旦信道进入confirm模式，所有在该信道上发布的消息都会指派一个**唯一的id**，一旦消息被投递到RabbitMQ服务中去，RabbitMQ就会发送一个确认给生产者。



**发送方确认其实还有事务机制**

channel.txSelect: 将当前的Channel设置为事务模式

channel.txCommit: 提交当前的事务

channel.txRollback: 事务回滚
跟数据库的事务比较像，也的确能解决发送方能确认消息是否发送到RabbitMQ中，但是事务机制很耗费性能，所以不提倡使用事务，仅供了解即可



### 如何确保消息接收方消费消息

消费方通过监听队列，从Channel中获取队列中存储的数据并进行消费——即为消费者订阅队列，可以设置autoAck参数，当autoAck为false时，RabbitMQ会等待消费者显示的回复确认信号之后，才会从内存（或者硬盘）中删除消息。



### 如何避免消息重复投递或重复消费

在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。  



### 如何确保消息不丢失

消息持久化的前提是：将交换器/队列的durable属性设置为true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要重新创建交换器/队列（交换器/队列会自动创建）。 



### 死信

1.消息被拒绝（basic.reject/ basic.nack）并且不再重新投递 requeue=false 

2.消息超期 (rabbitmq Time-To-Live -> messageProperties.setExpiration()) 

3.队列超载 

**变成了 “死信” 后 被重新投递（publish）到另一个Exchange 该Exchange 就是DLX 然后该Exchange 根据绑定规则 转发到对应的 队列上 监听该队列 就可以重新消费 说白了 就是 没有被消费的消息 换个地方重新被消费** 























