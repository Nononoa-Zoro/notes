#### 索引

- 什么是索引？

  索引是对数据库中的一列或者多列值进行排序的一种存储结构。

  

- 索引的类型

  1. **B+Tree 索引** ：InnoDB使用B+Tree存储索引，所有的值都是按顺序存储。

     B+树索引适用于：全键值匹配，键值范围，键前缀查询。

     InnoDB每一个页大小**16KB**，如果索引字段大小越大，每一个非叶子结点上的索引就会减少，树的深度就会增加，访问磁盘I/O的次数就会增加。


     查找一个数据时，存储引擎不会全表扫描数据，而是从根节点开始扫描。这些**非叶子结点**实际上定义了数据的**上下限**。可以判断待查找 数据在该节点的哪个部分。此外，叶子结点存储的是真实数据的地址。所有的叶子节点都通过链表的形式连接起来。

  B+Tree是顺序组织存储的，所以非常适合进行范围查询。比如找出一个以“1到K”字母开头的名字。

​     

     B+Tree 索引规则：**最左前缀查找**。索引(a,b,c.d)会一直匹配到**范围查询**，比如 a=1 and b=2 and c>3 and d=4 ,d是用不到索引的。但是建立(a,b,d,c)就可以。


​     

     比如建立索引(x,y)，实际存储的索引结构是(1,1)(1,2)(1,3)   (2,1)(2,2)(2,3)所以直接查y是不能用到索引的。


​     

  2. **哈希索引**： 基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会产生一个哈希值，同时保存指向每个数据行的指针。如果多个哈希值相同，即出现**哈希冲突**，则以链表的方式将多个记录保存到同一个哈希条目中。

    ​    

     **哈希索引与B+树索引的区别**：

     哈希索引只包含哈希值和行指针，不会存储字段。所以不能使用索引中的值来规避读取行。

    **哈希索引**数据不是按照索引值顺序存储的，所以**无法用于排序**。

    哈希索引需要用到整个字段， **不支持最左前缀查找**，因为哈希索引需要所有的字段计算哈希值。如(a,b)必须提供a,b值才可以。

     哈希索引只支持等值比较(=,IN(),<=>)。

     维护**哈希冲突**的代价可能会很高。

    

  3. **全文索引**
     用来查找文本中的关键词

###高性能的索引策略
1. “独立的列”：索引列不能是表达式的一部分。始终应该将索引放在比较符号的一侧。
actor_id=4;而不是下面这样

```sql
select actor_id from sakila.actor where actor_id+1=5;
```
上述SQL语句不能使用actor_id上的索引



2. 索引的选择性
  是指**不重复的索引值占表的记录总数的比例**。索引的选择性越高，查询的效率就越高。（不一样的值/总的个数）。如果这个值是1，证明所有的值都不一样，选择性高。对于BLOB,TEXT类型的数据必须使用前缀索引，所谓前缀索引就是选择足够长的前缀，使得前缀的选择性逼近完整列选择性。

  

3. 选择合适的索引列顺序
   经验原则：列选择性高的放在前面。

   

- 索引的优点

    1. 索引可以让服务器快速定位到目标的指定位置。

    2. B+Tree可以按照顺序存储数据，所以MYSQL可以用来做ORDER BY 和 GROUP BY操作。

    3. 索引减少了服务器需要扫描的数据量，帮助服务器避免排序和临时表。

    4. 索引将随机I/O变为顺序I/O。

    5. 索引可以帮助我们快速定位到对应的行，减少不必要的行锁定。

        

- 索引的缺点
    1. 创建索引和维护索引都需要消耗时间

    2. 索引需要占据额外的物理空间

       

- 哪些情况下会加索引
  1. 经常要搜索的列。

  2. 主键和外键

  3. 做范围查询和排序的列     

     

- 如果索引很长的字符列怎么办？

  1. 哈希索引。

  2. 只索引开始的部分字符，选取合适的字符序列使得不重复索引值最大（也称作基数），使用前面K个字符代替整个字符序列。

     

- mysql 联合索引（复合索引）

  多个列共同创建的索引，最左匹配特性。<https://cloud.tencent.com/developer/article/1030117>     

  

  三星索引：

  1. 索引可以将相关数据存放在一起。

  2. 索引中的数据顺序和查找中的排列顺序一致。

  3. 索引中的列包含了查询中需要的全部列。

     

  如何选择合适的索引列顺序？
  	经验法则：将选择性高的放在最前列。

###聚簇索引（一种数据的存储方式，在同一个B+Tree中保存了索引和数据行）

​	以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，则又往前翻。这本书本身就是一个索引，即“聚簇索引”。
	**Innodb的聚簇索引其实是在同一个B+Tree结构中保存了索引和数据行**。InnoDB通过主键聚集索引。没有主键列就会随机选择一个非空索引代替。

​	**聚簇索引的数据的物理地址和索引顺序是一致的**。也就是说，如果两个数据的索引相邻，则这两个数据的物理地址也是相邻的。

![聚簇索引和非聚簇索引的索引过程](d:\mdimage\timg.jpg)

​	上图中对于InnoDB一类的聚簇索引，如果使用非主键索引（也就是辅助索引），首先会通过辅助键索引找到对应的主键，然后通过主键索引拿到对应的数据行。

​	对于MYISAM一类的非聚簇索引存储而言，索引文件和数据文件是分开的，所以无论是采用主键索引还是辅助键索引都会首先去拿到对应的数据的物理地址，然后从磁盘中读取数据。



### 为什么InnoDB聚簇索引存储时，辅助索引叶子结点需要存储主键？

​	在辅助索引中存储主键会增加一定的开销（尤其是当主键很长的时候），但是当数据行改变时（比如数据删除或者数据移动），**辅助索引不需要维护数据的物理地址**，只需要维护数据的主键值，而主键值是不会改变的。



**注意**

对于innodb的主键值，**尽量选择递增的整数值**。因为innodb的叶子节点存储的是数据行。所以如果进行**页分裂**开销会很大。



**索引覆盖（explain 出现 Extra:using index）**

如果一个索引覆盖了我们需要查询的值，我们就称之为“覆盖索引”。

你想要查找的列，正好包含在了索引中，此时直接查索引文件就可以了，不需要再去回表查数据（回表就是指，去磁盘中查找数据）。

Innodb中二级索引如果包含我们需要的列，就可以直接从二级索引中拿数据而不需要回表查询。



**索引的优点**

1. 索引可以减少数据扫描的次数
2. 索引可以减少临时表的生成
3. 索引可以将随机IO变为顺序IO



**Innodb的主键应选择递增的整数**

Innodb的主键应该是递增的有序的整数值，这样在数据插入的时候就会将新的数据放在叶子结点后面。如果是随机的值作为主键，为了维护有序的索引结构会导致页分裂。而Innodb叶子节点中存放了数据，所以在内存中进行页分裂仍然会消耗很多资源。



####MYISAM使用前缀压缩索引

先保存第一个值，然后比较之后的和之前的。保存后面的与前面的相同前缀数，以及后面不同的部分。比如，第一个索引块是“perform"，下一块是"performance"。那么"performance"就会存储为7，mance。

代价：由于每一个索引都依赖之前的索引值，所以没有办法使用二分查找来找索引。只能从头开始扫描。



**索引越多越好？**

索引不是越多越好的。

建立索引可以帮助我们很快的进行数据查找，但是为了维护索引，我们的数据插入和修改就会很慢（因为索引是有序的）。



**排除重复索引和冗余索引**

重复索引：如，id primary key , unique key(id)。主键默认就是唯一索引，就不需要创建唯一索引了。

冗余索引：因为mysql在创建索引的时候会自动加上主键列，所以在创建联合索引的时候不要出现主键。如，key(name,id)。











