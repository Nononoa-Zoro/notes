##品优购业务&技术总结
###项目描述
>    品优购是公司自主研发的一个B2B2C电商平台,允许运营商自营和商家入驻,与京东商城非常类似。系统采用面向服务(SOA)分布式架构将不同的功能模块划分为多个子系统,其中包含运营商系统、商家系统、用户系统、网站前台系统、搜索系统、购物车系统、支付系统、订单系统、秒杀系统、CAS单点登录、短信&站内信微服务、客服系统等。系统采用dubbox+zookeeper实现面向服务的架构以及使用ssm框架整合完成后端功能模块，同时也使用多种技术完成整个项目的功能，比如安全框架Spring secutity、redis、消息中间件、页面静态化技术、全文检索技术等等，而前端采用AngularJs实现前后端分离。我主要负责的功能模块--从下面选择来讲
###一、整体业务
####1. 基础数据维护 

​     基础数据维护主要是对系统数据的创建，主要是对商品相关表数据进行维护包含品牌、规格、分类以及SPU和SKU管理。整体业务相对比较简单，实现过程页面利用AngularJs校验数据并提交请求传递相应数据,后端采用SpringMVC在controller处理请求和接收参数，同时通过dubbox调用远程发布到zookeeper服务层，服务层主要通过spring整合mybatis以mapper接口代理的方式完成数据的增删改查

​     技术点: Spring SpringMVC Mybatis

​                   dubbox+zookeeper

​		   dubbox的原理或者流程：

​			1) dubbox的角色：服务提供者  服务消费者 注册中心 --- 监听

​                        2) dubbox概念：基于rpc的分布式调度的框架

​                        3)  首先服务提供者采用Spring整合dubbox，主要通过配置文件配置dubbox的zookeeper注册中心以及包扫描还有发布服务的端口号，在对应的包中使用@Service注解来发布服务到zookeeper

​                        4) 服务消费采用SpringMVC整合dubbox配置包扫描，注册中心地址。在对应的包中使用@Reference注解远程注入服务

​                   zookeeper相关问题：

​			zookeeper介绍以及应用场景 : https://blog.csdn.net/king866/article/details/53992653/

​			zooKeeper是一个分布式的，开源的分布式协调服务，它采用目录结构存储数据，每一个节点成为Znode（四种类型的Znode，记可持久化的目录节点），zookeeper主要应用场景：命名服务、配置管理(zookeeper管理hadoop或者solr集群等配置文件)、分布式锁（watcher: 保证注册的服务只能被消费一次同时客户端调用时同步串行话）

​                      zookeeper底层：数据模型结构以目录方式进行存储，每一个目录称为Znode节点

​                      zookeeper集群的回答：leader选举  为什么节点个数时奇数

​     概念：

​     spu是标准产品单位表主要存储商品名称、规格、分类、所属商家id、价格、商品介绍等

​     sku是标准库存单位，是spu+每一种规格的组合。商品的库存都是以sku为准。一个spu对应多个sku

####2. 权限管理维护 

​     权限模块在运营商后台进行维护，主要功能是维护用户表和角色表数据同时给运营商后台用户进行角色配置，一个用户可以拥有多种角色。同时使用spring security配置请求拦截规则，系统规定每一个功能模块都有一种特定的角色，比如如果要操作用户模块那么用户就需要有用户角色(ROLE_USER)。同时实现spring security提供的认证接口UserDetailService的loadByUsername方法根据传入用户名查询用户表得到用户密码以及根据用户名查询角色表得到当前用户所有的角色信息，完成角色的认证.在spring security的认证管理器中配置刚刚实现的认证类同时加入Bcrypt加密配置。同时商家系统也需要相应的角色才能访问，在运营商后台由管理人员对商家进行赋予角色(商家用户角色比较单一:普通角色、VIP角色、秒杀角色等)

网站权限的细粒度 --- 定位到方法|请求，每一个请求对可以对应一个权限

Shiro： 用户  角色 权限

####3. 网站首页

​     网站前台首页，首页主要展示广告信息、热门商品信息、分类菜单等。由于网站首页作为入口，访问压力较大。为了减轻数据库的访问压力并且提高系统的平均响应时间，而且首页数据的变换并不频繁所以可以将首页所需数据使用redis进行缓存，这样访问首页时数据加载就从缓存中获取，不去访问数据库。同时如果后台对广告更换以及分类更改都会清空相应的缓存，这样下次访问从新先从数据库加载然后再存入缓存，之后读取都从缓存读取。

​    技术：redis

   1) redis介绍

​	Redis 是一个基于内存的高性能key-value数据库， Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。Redis支持数据的备份，即master-slave模式的数据备份。同时redis允许单个value的最大限制是1GB，不像 memcached(简单的key-value缓存工具)只能保存1MB的数据。还可以对key设置过去时间( expire(key,5000) )，Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，如果是海量数据通常采用mongoDB存储还有就是redis是单线程的

   2) 使用Redis有哪些好处？

​       丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

​      速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1), [注：O(1)是时间复杂度，也就是一步就可以通过key获得value]  

​      支持丰富数据类型，支持string，list，set，sorted set，hash
​      支持事务，操作不都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行，redis的事务时弱事务，它不保证一个事务之类的命令要么全部成功要么全部失败

   3) redis持久化机制--- 将数据持久化到磁盘，下一次重启将可以重新同步

​       RDB 持久化:Redis 会单独的创建(fork) 一个子进程来进行在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 snapshot 快照，它恢复时就是将快照文件直接读到内存里。RDB 的缺点是最后一次持久化后的数据可能丢失。

redis会创建单点的子进程来把内存中的数据在指定时间间隔内满足操作多少次修改命令就会将数据快照写入到 dump.rdb。

缺点：最后一次的快照不能写入磁盘，数据可能丢失

​       AOF 持久化:以日志的形式记录每个写操作，将 redis 执行过的所有写指令记录下来(读操作不记录)

写入到appendonly.aof这个文件，持久化的时机可以配置 always everysec no。

优点：数据丢失概率降低，缺点：占用磁盘内存

   4) AOF持久化文件越来越大怎么办？

​       Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合，对以前的命令进行压缩。

​	作为开发人员处理方法：采用定时任务在每月的最后一天将日志文件备份到磁盘其他位置，接着将aof删除。之后redis又会重新生成新的aof文件,如果redis发送故障需要重新同步数据，则将之前的日志文件整合在放入redis启动即可

   5) redis 集群相关的介绍

​	描述：Redis集群搭建的方式有多种，例如使用客户端分片、Twemproxy、Codis等，但从redis 3.0之后版本支持redis-cluster集群，它是Redis官方提出的解决方案，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。所有的 redis 节点彼此互联(PING-PONG 机制),内部使用二进制协议优化传输速度和带宽.redis集群一般可扩展性的master主节点，同时每一个master一般配置一个slave从节点。所有的master占满redis集群的16384个哈希槽。而master与slave采用主从机制，master采用单独的后台线程以发送快照的方式与slave节点同步数据，所以不会影响整个redis的性能。

​       节点故障判定规则:集群中所有master参与,如果半数以上master节点与故障节点通信超过(cluster-node-timeout),认为该节点故障。那么该节点得slave从节点就升级为master节点

​        什么时候整个集群不可用:集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态

   7) 如何保证首页热门商品都是较新的？

​	答：热门商品主要时由用于VIP角色或者月销售量前10的商品才能展示。

​		可以采用任务定时器，在晚上12点执行统计VIP前10和月销售10来进更新

####4. 商品搜索系统

​      搜索业务主要是在搜索页面构建一个封装有关键字和过滤条件(品牌、规格、分类)的变量利用angularJS传递到后台，后台接收到这些关键字和过滤条件之后利用spring data solr去solr服务器进行关键字搜索对同时对搜索结果根据过滤条件来进行筛选，页面中的过滤条件是和搜索关键字相关的，过滤条件是根据关键字查询索引库得到相关的分类，再根据分类查询数据库得到关联的规格和品牌，同时由于商品搜索访问是非常频繁，所以在运营商进行分类管理时将分类所关联的规格和品牌全部利用redis缓存，而过滤面板根据关键字得到的数据就直接从redis中获取。

​      索引同步业务：使用activeMQ来完成商品索引同步，主要功能是当商家在对商品进行上架或者下架(运营商删除)的时候利用Spring整合activeMQ发送点对点消息给搜索服务来同步添加或者删除索引库



​      概念：消息队列，用于解决分布式系统之间异步调用(异步通信)，从而解决系统的响应时间较慢以及分布式系统之间模块与模块之间耦合，消息类型如下：
	1.点对点(queue)
	      》一个消息只能被一个消费者消费
	      》消息一旦被消费，就会失效，不能重复被消费
	      》如果没有被消费，就会一直等待，直到被消费
	      》多个服务监听同一个服务生产者，先到先得
	2.发布/订阅模式(topic)
	 　 》一个消息可以被多个消费者消费
	　　》消费端如果在生产端者发送消息之后启动，是接收不到消息的，除非生产者对消息进行了持久化(例如广播，只有当时听到的人能听到信息)
	持久化机制：ActiveMQ默认的持久化方式仍然是KahaDB，在ActiveMQ 5.9版本提供了基于LevelDB和Zookeeper的数据复制方式，用于Master-slave方式的首选数据复制方案
消息丢失如何处理？  -- 防止消息丢失，并且如果消息丢失之后我们如果补偿消息丢失导致某些业务没有执行

答：将activeMQ发送的消息记录下来存到redis中(   hash("MQLog").put(UUID,数据结构 )  )，并且创建一个数据结构，{ UUID:UUID,status:0,time:当前发送消息的时间,data:{原本消息中具体内容}  }，利用activeMQ发送消息，消息正文是之前创建的数据结构。消息如果被消费者成功消费，就将redis对应的记录把状态修改{ UUID:UUID,status:1,time:消息的时间，data:{原本消息中具体内容}  }; 之后利用定时任务处理如果状态是0并且时间超过5分钟的消息，直接获取redis中的原本的消息内容，然后直接调用对应的service服务

- 防止消息重复被消费   

  只需要在activeMQ消费者监听中判断一下消息在redis中的状态，如果是1，是就直接结束。

Solr服务器的搭建：

	单机版： 
	1) 将solr官方提供war放到tomcat
	2) 导入相关jar
	3) 配置中分分词器
	4) 定义与业务相关域
	集群版：(私下进行搭建)
	1) 集群版solr所有的节点的配置文件都交给zookeeper进行管理
	2) 先搭建zookeeper集群
		搭建好之后存在leader和follower,要求zookeeper节点个数为奇数。
		原因(1) 选举leader超过半数 
			(2) 容错能力
			 3) 搭建solr集群利用solrCloud 进行配置，将所有solr配置文件上传
				zookeeper进行管理
solr介绍：
	solr是一个全文检索服务器，运行依赖于servlet容器比如tomcat,Jetty等，底层采用Lucene来完成对索引创建和查询。它提供了基于HTTP请求一套操作，并且支持多种数据响应(json,xml等)，所以它能够跨语言而lucene只能在java中使用
solr的底层原理：

	solr的底层是基于Lucene。而lucene的原理主要包含索引创建和索引搜索两部分。
	   索引创建：将原始文档(数据源)使用分词组件来将数据源的内容拆分为一个一个的单词，期间还会去掉标点符号去掉停用词 。经过分词之后会得到许多词汇，接着讲这些词汇传递给语言处理组件，语言处理组件主要就是将大写转为小写等功能，经过语言处理组件处理之后就得到语汇单元（term）,最后就对语汇单元term创建索引形成以语汇单元term的反向索引。反向索引是以term作为开头的一个文档链表，只要原始文档包含term这个语汇单元的都会出现在该term的文档链表中 	
	    索引搜索：将需要查询的关键字先进行分词，得到语汇单元term，然后将这些语汇单元的文档链表返回即可得到原始文档的内容。
	同时solr提供基于Http请求的方式完成索引的维护。
####5. 商品详情页生成服务系统

​     该功能实现当商家进行上架时利用activeMQ将当前商品id以发布订阅的消息类型发送给页面静态化服务，静态化服务监听到到商品id就去查询数据库获得当前商品的相关信息并且利用freemarker将数据加载到事先定义好模板中，这样就可以按照模板生成静态页面并且利用程序以商品id为文件名存入到Nginx指定目录，之后就可以直接通过Nginx访问商品详情页。

​    静态页面同步：商家进行上架或者下架是完成对静态页面的生成和删除。

​    静态页面库存：

​        1) 静态化页面不显示库存信息，在点击加入购物车的时候判断数据库库存信息是否足够

​        2) 如果需要显示当前商品库存信息，那么就通过商品id去异步获取商品库存就可以了

####6. CAS单点登陆系统

​	CAS是一个单点登录服务器，分为 CAS server和CAS client。CAS server是一个独立部署的 Web 应用，用于完成对用户的登陆以及用户凭证的记录。CAS client是一个应用集成CAS的子系统，也就是对资源起保护作用的功能模块。当浏览器在未登录情况下请求服务器A被保护资源(cas客户端),由于保护的资源被CAS Client保护，所以CAS Client会重定向到CAS server，CAS server检查是否有全局会话ID，由于没有登录，所以没有全局会话ID则CAS server会重定向到登录页面，当用户在登录页面输入正确的用户名和密码后，会将请求发送到CAS server,CAS server就会产生全局会话ID，同时会携带一个认证票据到重定向到服务器A被保护的资源，被保护资源的服务器A会把携带回来的认证票据再次与CAS server进行验证，验证通过后服务器A则会在浏览器创建一个局部会话ID,之后浏览器请求服务器A的被保护资源都通过局部会话ID进行通信。此时浏览器已经登录成功了，此时浏览器访问服务器B的保护资源，由于资源同样被CAS client保护则同样会重定向到CAS server，由于CAS server已经存在全局会话ID则CAS server直接携带认证票据并重定向服务器B保护的资源，同时服务器B同样将认证票据发送给CAS server进行认证，认证通过服务器B则会与浏览器创建局部会话ID，之后浏览器访问服务器B的资源都通过局部会话ID。同时如果退出cas登录，那么cas clinet配置了相关的退出登录监听就会生效去清除服务器与浏览器之间的局部会话id，实现退出登录

​	用redis来模拟session实现单点登陆：

	流程：
	1) 当用户登陆成功时，将用户信息存到redis中，数据结构 hash("UserLogin").put(UUID,用户信息)
	2) 存储到redis之后，创建一个Cookie,
		Cookie cookie = new Cookie("login-cookie",UUID);
		cookie.setMaxAge(30*60*1000);//设置有效时间
		cookie.setDomain("pyg.com");//设置为一级域名  www.pyg.com search.pyg.com item.pyg.com  
		cookie.setPath("/");
	3) 将cookie利用response写入浏览器
	4) 后面当前浏览器发送的任何请求都可以将该cookie带到服务器端,在服务端获得cookie，并且如果cookie不为空，那么就从redis中获取相应用户信息，获得之后判断用户信息是否为空。
####7. 购物车系统

购物车模块的实现和京东类似，有两种状态——未登录状态购物车和登录状态购物车
 1). 未登录状态购物：未登录情况下加入购物车，所添加的购物车信息保存在cookie中。保存时间为1天。以“cartList”作为cookie的key，value是一个JSON字符串。保存了具体购物项信息，每次对购物项进行操作都会改变当前cookie中购物车对应的数据。
  2). 登录状态购物车:已登录情况下购物车，是存放在redis缓存中。redis中采用hash值来存放所有购物车信息。hash值中以每个用户名为key，以json字符串存放当前用户名所添加的购物车信息，每次对购物项进行操作都会改变当前redis购物车中对应的数据。在登录情况下，查询购物车列表时，判断cookie购物车中是否存在购物项，如果存在则将这些购物项合并到redis缓存购物车中去，并且清空cookie购物车。
 同时由于系统采用的是分布式部署，存在多个系统可以添加购物车。此时就涉及到跨域请求的问题，跨域请求解决方案有JSONP和CORS。品优购采用CORS来解决跨域请求，CORS跨来源资源共享是一份浏览器技术的规范只需要在服务端设置一个允许响应请求的响应头信息，同时由于购物车需要获取和响应cookie还要分别在浏览器请求设置允许请求带上cookie和服务端运行响应带上cookie.

问题：

1). 用户恶意频繁添加购物车?

​	(1).  限制每个用户或者IP对应的购物车购买数量

​	(2).  如果频繁添加购物车，当同一用户或者同一IP5秒之类添加次数超过10次，就需要输入验证码才能进行再次添加。

2). cookie禁用怎么办?

 ------最好回答：如果禁用cookie那么我们的系统禁止访问  哈哈。

url重写技术:
     1）访问当前系统就返回浏览器一个token--UUID,该token对应redis缓存中的key -- value
     2）每次浏览器与服务器进行跳转页面交互，浏览器需要发送token参数，如果服务器没有接收到token就重新生成再返回给浏览器。这个浏览器和服务器之间就通过token来建立会话
     (这样的话，未登录情况下的cookie购物车就不能使用,这个时候也可以把未登录情况下的购物车写入redis中。但是redis中存购物车是通过token来作为key，value也是JSON字符串。)
java后台写了一个登陆接口;

​	        APP实现登陆功能;后台需要返回给手机APP端返回一个token，该token在app每一次发送请求给服务器时必须带过来，这样就可以达到会话跟踪。

####8. 短信微服务

微服务概念：将应用程序分解为更小、完全独立的组件，这使得它们拥有更高的敏捷性、可伸缩性和可用性。简单说就是一个可以独立运行、与具体业务无关、专门完成某一类功能的服务 -- 可独立运行的工具类

利用Spring Boot整合阿里大于短信SDK来发送短信，同时如果需要调用短信微服务只需要利用activeMQ发送相关的点对点短信消息，短信微服务利用Spring Boot整合activeMQ监听。拿到消息就调用短信SDK发送短信即可

SpringBoot介绍：

Spring Boot是一个基于Spring4.X以Java注解配置的快速开发框架，能够快速搭建一个企业级的项目。很好的将很多技术进行了集成，只需要很简单配置就可以使用。它将Spring集成其他技术的习惯性配置进行内置优化，并且它内置了servlet容器。所以它可以使用main方法启动，在创建maven项目时也选择jar打包方式。对于Spring Boot的启动类必须有@SpringBootApplication注解，该注解主要目的是开启自动配置。同时需要注意这个类只会扫描与其载相同包的类或者在它所在包的子包下的类，其他地方的类上额@service、@controller等注解不会被扫描。

优点：

​	快速构建项目
​	对主流的框架无配置化集成，极大提高了开发、部署效率
​	项目可独立运行，无需依赖Servlet容器
​	提供运行时的应用监控

缺点：只是对于大型项目比较适合，对于小型网站依赖太多，大材小用了

####9. 秒杀系统

秒杀系统主要问题在于，如果采用传统代码实现会造成: 1) 库存超卖  2) 数据库访问压力过大

解决库存超卖：采用加锁 ---- 乐观锁和悲观锁

​        悲观锁机制：每次去操作据的时候都认为别人会修改，所以每次在操作的时候都会上锁，这样别人想拿操作数据就会block直到它拿到锁，使用java中的synchronized|Lock。悲观锁优缺点——但是时间会非常长，性能较差悲观锁能够保证程序的正确按资源分配一个一个来执行，并且能够成功。

​	数据库乐观锁机制：在数据库中可以定义一个version字段，在操作之前先获取当前数据的version，在执行将获得的version当作参数传递到数据库，提交时判断当前的version和传入的version是否一致，如果不一致则认为别人已经操作过当前version，就不允许提交。乐观锁优缺点——程序执行性能有所优化，但是即使库存足够时也会有很多请求不能抢购成功。

解决数据库访问压力：采用redis

​	数据库的连接时有限的，而秒杀是一个高并发的场景，如果直接操作数据库那么就会造成数据库连接不够用，就算采用c3p0连接池在单机测试1000并发也会报连接不够用，采用druid连接池则不会，毕竟是最快的连接池技术。所以采用redis将秒杀商品缓存起来，然后可以利用redis提供的watch乐观锁+事务(multi exec discard)的方式既可以解决超卖同时也能降低数据库的访问压力，但是乐观锁的弊端还是存在——库存满足也会有很多请求不能抢到商品。

​        redis令牌机制实现秒杀业务:

	1)  利用定时任务将某些商品再30分钟之后要开启秒杀根据库存量同步到redis，
		根据每一个商品生成对应token数量，采用redis中的list数据类型存储某个商品的令牌
		----------------------------------------------------------------------------
		采用list数据类型存储的原因主要时每一个线程取从list中pop时是单线程处理，所以每一个线程
		拿到token就不可能是同一个。
	2)  再秒杀期间，每一个用户都去获得对应商品中的令牌
		验证令牌 --  判断令牌是否有效 (非空判断，如果时已经支付的token就不能再次被抢够)
	3)  超时未支付，归还令牌
	4)  支付成功，生成订单，标记当前令牌已经被支付，同时删除当前令牌
###二、技术整理
####1. dubbox技术

​     参照《面试高级技术.xmind》  --  dubbo&dubbox

####2. zookeeper技术

   参照《面试高级技术.xmind》  --   zookeeper

>https://www.toutiao.com/i6558438316537020941/
####3. redis技术整理

  参照《面试高级技术.xmind》  --   缓存

>推荐网站：https://www.toutiao.com/i6566017785078481422/  
>https://www.toutiao.com/i6579583194893386254/
####4. activeMQ消息中间件

​    参照《面试高级技术.xmind》  --   消息中间件

#### 7. CORS跨域&JSONP跨域

​    参照《面试高级技术.xmind》 --  跨域解决方案

####8. SpringTask任务调度

​    参照品优购课程第20天讲解的Spring Task。只要会cron表达式即可

####9. 阿里大于短信SDK接入

   1) 注册阿里云账号

   2) 认证

   3) 申请短信签名

   4) 申请短信模板

   5) 下载短信SDK

####10.微信支付接口接入

​	参照《面试高级技术.xmind》 --  微信支付接入

####11.数据库分库分表

​	参照《面试高级技术.xmind》  -- 数据库分库分表

###三、项目开发
####1.流程

	1) 需求调研 - 需求文档  
	2) 开发文档 - 包含业务和页面原型 --  页面代码  --- 交给美工作图，前端开发根据图纸完成页面
	3) (前后端分离的方式) 项目经理会根据业务，编写一个接口文档
	4) 安排任务 - excel文档标注你要完成哪些功能，每一个功能所选要时间
	5) 提前时间熟悉自己所作功能的业务
	      5.1) 分析业务功能如何实现，要知道现在要做什么功能
		  5.2) 熟悉业务所涉及到的数据库表（如果从文档中不能确定有哪些表，问组长 技术负责人）
				涉及到表与表之间的关系
				同时要理清楚页面原型中的数据和数据库的表字段的对应关系，或者接口文档中参数与数据库表的字段的对应关系
		  5.3) 业务的细节： 做一些数据验证，判断是否登陆才能操作之类
	6) 写代码，遵循公司的规范。--- 找个朋友好好带你整理一次流程，如果没有朋友，直接找技术负责人
	7) 每天下班的时候记得把完成功能(可运行的代码)提交svn git
####2.环境	
	生产环境 - 上线 时间： 周期：10%
	开发环境 - 代码 时间： 开发周期*30% - 40%
	测试环境 - bug  时间： 周期：40% - 50%

####3.人员配置

	项目组：5-7
	开发人员：4左右
	项目经理：1
	技术负责人：1
	前端：2-3
<hr/>

##相关面试题
####java基础面试
>《java基础常见面试总结.doc》--java基础部分
>《JAVAEE精选面试题101.docx》
####java多线程编程
>https://www.toutiao.com/i6591036272595173896/      
>https://www.toutiao.com/i6476296955273150989/   
>http://www.importnew.com/12773.html<br/>              	 
>乐观锁&悲观锁：https://www.toutiao.com/i6555703140056826375/   
>线程池：https://www.toutiao.com/i6586427412609761799/
####java虚拟机
>垃圾回收机制：https://www.toutiao.com/i6564396864349667848/  
>JVM：https://www.toutiao.com/i6552489606078530061/
>https://blog.csdn.net/hsk256/article/details/49104955
####mysql优化
>https://www.toutiao.com/i6564144479245173255/
####框架面试题
>Hibernate框架：https://blog.csdn.net/qq1137623160/article/details/71194677
>MyBatis框架：https://www.toutiao.com/i6563966524543992334/  
>Spring框架：https://www.toutiao.com/i6587363617916584461/  
>Spring框架：https://www.toutiao.com/i6586253099294261764/
>SpringMVC框架：https://blog.csdn.net/xinghuo0007/article/details/53463897
####分布式事务
>分布式事务:https://www.toutiao.com/i6559108587187077646/
####设计模式
>尽量掌握单例模式、装饰者模式、工厂模式、适配器模式：
>https://www.cnblogs.com/tongkey/p/7170826.html
####排序算法
>冒泡算法:https://www.cnblogs.com/jingmoxukong/p/4302718.html  
>快速算法:https://www.cnblogs.com/jingmoxukong/p/4302891.html

